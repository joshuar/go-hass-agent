// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package api

import (
	"sync"
)

// Ensure, that ResponseMock does implement Response.
// If this is not the case, regenerate this file with moq.
var _ Response = &ResponseMock{}

// ResponseMock is a mock implementation of Response.
//
//	func TestSomethingThatUsesResponse(t *testing.T) {
//
//		// make and configure a mocked Response
//		mockedResponse := &ResponseMock{
//			DisabledFunc: func() bool {
//				panic("mock out the Disabled method")
//			},
//			ErrorFunc: func() error {
//				panic("mock out the Error method")
//			},
//			RegisteredFunc: func() bool {
//				panic("mock out the Registered method")
//			},
//			TypeFunc: func() RequestType {
//				panic("mock out the Type method")
//			},
//		}
//
//		// use mockedResponse in code that requires Response
//		// and then make assertions.
//
//	}
type ResponseMock struct {
	// DisabledFunc mocks the Disabled method.
	DisabledFunc func() bool

	// ErrorFunc mocks the Error method.
	ErrorFunc func() error

	// RegisteredFunc mocks the Registered method.
	RegisteredFunc func() bool

	// TypeFunc mocks the Type method.
	TypeFunc func() RequestType

	// calls tracks calls to the methods.
	calls struct {
		// Disabled holds details about calls to the Disabled method.
		Disabled []struct {
		}
		// Error holds details about calls to the Error method.
		Error []struct {
		}
		// Registered holds details about calls to the Registered method.
		Registered []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
	}
	lockDisabled   sync.RWMutex
	lockError      sync.RWMutex
	lockRegistered sync.RWMutex
	lockType       sync.RWMutex
}

// Disabled calls DisabledFunc.
func (mock *ResponseMock) Disabled() bool {
	if mock.DisabledFunc == nil {
		panic("ResponseMock.DisabledFunc: method is nil but Response.Disabled was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDisabled.Lock()
	mock.calls.Disabled = append(mock.calls.Disabled, callInfo)
	mock.lockDisabled.Unlock()
	return mock.DisabledFunc()
}

// DisabledCalls gets all the calls that were made to Disabled.
// Check the length with:
//
//	len(mockedResponse.DisabledCalls())
func (mock *ResponseMock) DisabledCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDisabled.RLock()
	calls = mock.calls.Disabled
	mock.lockDisabled.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *ResponseMock) Error() error {
	if mock.ErrorFunc == nil {
		panic("ResponseMock.ErrorFunc: method is nil but Response.Error was just called")
	}
	callInfo := struct {
	}{}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	return mock.ErrorFunc()
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedResponse.ErrorCalls())
func (mock *ResponseMock) ErrorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Registered calls RegisteredFunc.
func (mock *ResponseMock) Registered() bool {
	if mock.RegisteredFunc == nil {
		panic("ResponseMock.RegisteredFunc: method is nil but Response.Registered was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRegistered.Lock()
	mock.calls.Registered = append(mock.calls.Registered, callInfo)
	mock.lockRegistered.Unlock()
	return mock.RegisteredFunc()
}

// RegisteredCalls gets all the calls that were made to Registered.
// Check the length with:
//
//	len(mockedResponse.RegisteredCalls())
func (mock *ResponseMock) RegisteredCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRegistered.RLock()
	calls = mock.calls.Registered
	mock.lockRegistered.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *ResponseMock) Type() RequestType {
	if mock.TypeFunc == nil {
		panic("ResponseMock.TypeFunc: method is nil but Response.Type was just called")
	}
	callInfo := struct {
	}{}
	mock.lockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	mock.lockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//
//	len(mockedResponse.TypeCalls())
func (mock *ResponseMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockType.RLock()
	calls = mock.calls.Type
	mock.lockType.RUnlock()
	return calls
}
