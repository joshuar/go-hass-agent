// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sensor

import (
	"github.com/joshuar/go-hass-agent/internal/hass/sensor/types"
	"sync"
)

// Ensure, that StateMock does implement State.
// If this is not the case, regenerate this file with moq.
var _ State = &StateMock{}

// StateMock is a mock implementation of State.
//
//	func TestSomethingThatUsesState(t *testing.T) {
//
//		// make and configure a mocked State
//		mockedState := &StateMock{
//			AttributesFunc: func() any {
//				panic("mock out the Attributes method")
//			},
//			IDFunc: func() string {
//				panic("mock out the ID method")
//			},
//			IconFunc: func() string {
//				panic("mock out the Icon method")
//			},
//			SensorTypeFunc: func() types.SensorClass {
//				panic("mock out the SensorType method")
//			},
//			StateFunc: func() any {
//				panic("mock out the State method")
//			},
//			UnitsFunc: func() string {
//				panic("mock out the Units method")
//			},
//		}
//
//		// use mockedState in code that requires State
//		// and then make assertions.
//
//	}
type StateMock struct {
	// AttributesFunc mocks the Attributes method.
	AttributesFunc func() any

	// IDFunc mocks the ID method.
	IDFunc func() string

	// IconFunc mocks the Icon method.
	IconFunc func() string

	// SensorTypeFunc mocks the SensorType method.
	SensorTypeFunc func() types.SensorClass

	// StateFunc mocks the State method.
	StateFunc func() any

	// UnitsFunc mocks the Units method.
	UnitsFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Attributes holds details about calls to the Attributes method.
		Attributes []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Icon holds details about calls to the Icon method.
		Icon []struct {
		}
		// SensorType holds details about calls to the SensorType method.
		SensorType []struct {
		}
		// State holds details about calls to the State method.
		State []struct {
		}
		// Units holds details about calls to the Units method.
		Units []struct {
		}
	}
	lockAttributes sync.RWMutex
	lockID         sync.RWMutex
	lockIcon       sync.RWMutex
	lockSensorType sync.RWMutex
	lockState      sync.RWMutex
	lockUnits      sync.RWMutex
}

// Attributes calls AttributesFunc.
func (mock *StateMock) Attributes() any {
	if mock.AttributesFunc == nil {
		panic("StateMock.AttributesFunc: method is nil but State.Attributes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAttributes.Lock()
	mock.calls.Attributes = append(mock.calls.Attributes, callInfo)
	mock.lockAttributes.Unlock()
	return mock.AttributesFunc()
}

// AttributesCalls gets all the calls that were made to Attributes.
// Check the length with:
//
//	len(mockedState.AttributesCalls())
func (mock *StateMock) AttributesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAttributes.RLock()
	calls = mock.calls.Attributes
	mock.lockAttributes.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *StateMock) ID() string {
	if mock.IDFunc == nil {
		panic("StateMock.IDFunc: method is nil but State.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedState.IDCalls())
func (mock *StateMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Icon calls IconFunc.
func (mock *StateMock) Icon() string {
	if mock.IconFunc == nil {
		panic("StateMock.IconFunc: method is nil but State.Icon was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIcon.Lock()
	mock.calls.Icon = append(mock.calls.Icon, callInfo)
	mock.lockIcon.Unlock()
	return mock.IconFunc()
}

// IconCalls gets all the calls that were made to Icon.
// Check the length with:
//
//	len(mockedState.IconCalls())
func (mock *StateMock) IconCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIcon.RLock()
	calls = mock.calls.Icon
	mock.lockIcon.RUnlock()
	return calls
}

// SensorType calls SensorTypeFunc.
func (mock *StateMock) SensorType() types.SensorClass {
	if mock.SensorTypeFunc == nil {
		panic("StateMock.SensorTypeFunc: method is nil but State.SensorType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSensorType.Lock()
	mock.calls.SensorType = append(mock.calls.SensorType, callInfo)
	mock.lockSensorType.Unlock()
	return mock.SensorTypeFunc()
}

// SensorTypeCalls gets all the calls that were made to SensorType.
// Check the length with:
//
//	len(mockedState.SensorTypeCalls())
func (mock *StateMock) SensorTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSensorType.RLock()
	calls = mock.calls.SensorType
	mock.lockSensorType.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *StateMock) State() any {
	if mock.StateFunc == nil {
		panic("StateMock.StateFunc: method is nil but State.State was just called")
	}
	callInfo := struct {
	}{}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc()
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedState.StateCalls())
func (mock *StateMock) StateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Units calls UnitsFunc.
func (mock *StateMock) Units() string {
	if mock.UnitsFunc == nil {
		panic("StateMock.UnitsFunc: method is nil but State.Units was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnits.Lock()
	mock.calls.Units = append(mock.calls.Units, callInfo)
	mock.lockUnits.Unlock()
	return mock.UnitsFunc()
}

// UnitsCalls gets all the calls that were made to Units.
// Check the length with:
//
//	len(mockedState.UnitsCalls())
func (mock *StateMock) UnitsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnits.RLock()
	calls = mock.calls.Units
	mock.lockUnits.RUnlock()
	return calls
}
