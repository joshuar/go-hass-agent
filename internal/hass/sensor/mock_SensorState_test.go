// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package sensor

import (
	"sync"
)

// Ensure, that SensorStateMock does implement SensorState.
// If this is not the case, regenerate this file with moq.
var _ SensorState = &SensorStateMock{}

// SensorStateMock is a mock implementation of SensorState.
//
//	func TestSomethingThatUsesSensorState(t *testing.T) {
//
//		// make and configure a mocked SensorState
//		mockedSensorState := &SensorStateMock{
//			AttributesFunc: func() any {
//				panic("mock out the Attributes method")
//			},
//			IDFunc: func() string {
//				panic("mock out the ID method")
//			},
//			IconFunc: func() string {
//				panic("mock out the Icon method")
//			},
//			SensorTypeFunc: func() SensorType {
//				panic("mock out the SensorType method")
//			},
//			StateFunc: func() any {
//				panic("mock out the State method")
//			},
//			UnitsFunc: func() string {
//				panic("mock out the Units method")
//			},
//		}
//
//		// use mockedSensorState in code that requires SensorState
//		// and then make assertions.
//
//	}
type SensorStateMock struct {
	// AttributesFunc mocks the Attributes method.
	AttributesFunc func() any

	// IDFunc mocks the ID method.
	IDFunc func() string

	// IconFunc mocks the Icon method.
	IconFunc func() string

	// SensorTypeFunc mocks the SensorType method.
	SensorTypeFunc func() SensorType

	// StateFunc mocks the State method.
	StateFunc func() any

	// UnitsFunc mocks the Units method.
	UnitsFunc func() string

	// calls tracks calls to the methods.
	calls struct {
		// Attributes holds details about calls to the Attributes method.
		Attributes []struct {
		}
		// ID holds details about calls to the ID method.
		ID []struct {
		}
		// Icon holds details about calls to the Icon method.
		Icon []struct {
		}
		// SensorType holds details about calls to the SensorType method.
		SensorType []struct {
		}
		// State holds details about calls to the State method.
		State []struct {
		}
		// Units holds details about calls to the Units method.
		Units []struct {
		}
	}
	lockAttributes sync.RWMutex
	lockID         sync.RWMutex
	lockIcon       sync.RWMutex
	lockSensorType sync.RWMutex
	lockState      sync.RWMutex
	lockUnits      sync.RWMutex
}

// Attributes calls AttributesFunc.
func (mock *SensorStateMock) Attributes() any {
	if mock.AttributesFunc == nil {
		panic("SensorStateMock.AttributesFunc: method is nil but SensorState.Attributes was just called")
	}
	callInfo := struct {
	}{}
	mock.lockAttributes.Lock()
	mock.calls.Attributes = append(mock.calls.Attributes, callInfo)
	mock.lockAttributes.Unlock()
	return mock.AttributesFunc()
}

// AttributesCalls gets all the calls that were made to Attributes.
// Check the length with:
//
//	len(mockedSensorState.AttributesCalls())
func (mock *SensorStateMock) AttributesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockAttributes.RLock()
	calls = mock.calls.Attributes
	mock.lockAttributes.RUnlock()
	return calls
}

// ID calls IDFunc.
func (mock *SensorStateMock) ID() string {
	if mock.IDFunc == nil {
		panic("SensorStateMock.IDFunc: method is nil but SensorState.ID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockID.Lock()
	mock.calls.ID = append(mock.calls.ID, callInfo)
	mock.lockID.Unlock()
	return mock.IDFunc()
}

// IDCalls gets all the calls that were made to ID.
// Check the length with:
//
//	len(mockedSensorState.IDCalls())
func (mock *SensorStateMock) IDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockID.RLock()
	calls = mock.calls.ID
	mock.lockID.RUnlock()
	return calls
}

// Icon calls IconFunc.
func (mock *SensorStateMock) Icon() string {
	if mock.IconFunc == nil {
		panic("SensorStateMock.IconFunc: method is nil but SensorState.Icon was just called")
	}
	callInfo := struct {
	}{}
	mock.lockIcon.Lock()
	mock.calls.Icon = append(mock.calls.Icon, callInfo)
	mock.lockIcon.Unlock()
	return mock.IconFunc()
}

// IconCalls gets all the calls that were made to Icon.
// Check the length with:
//
//	len(mockedSensorState.IconCalls())
func (mock *SensorStateMock) IconCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockIcon.RLock()
	calls = mock.calls.Icon
	mock.lockIcon.RUnlock()
	return calls
}

// SensorType calls SensorTypeFunc.
func (mock *SensorStateMock) SensorType() SensorType {
	if mock.SensorTypeFunc == nil {
		panic("SensorStateMock.SensorTypeFunc: method is nil but SensorState.SensorType was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSensorType.Lock()
	mock.calls.SensorType = append(mock.calls.SensorType, callInfo)
	mock.lockSensorType.Unlock()
	return mock.SensorTypeFunc()
}

// SensorTypeCalls gets all the calls that were made to SensorType.
// Check the length with:
//
//	len(mockedSensorState.SensorTypeCalls())
func (mock *SensorStateMock) SensorTypeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSensorType.RLock()
	calls = mock.calls.SensorType
	mock.lockSensorType.RUnlock()
	return calls
}

// State calls StateFunc.
func (mock *SensorStateMock) State() any {
	if mock.StateFunc == nil {
		panic("SensorStateMock.StateFunc: method is nil but SensorState.State was just called")
	}
	callInfo := struct {
	}{}
	mock.lockState.Lock()
	mock.calls.State = append(mock.calls.State, callInfo)
	mock.lockState.Unlock()
	return mock.StateFunc()
}

// StateCalls gets all the calls that were made to State.
// Check the length with:
//
//	len(mockedSensorState.StateCalls())
func (mock *SensorStateMock) StateCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockState.RLock()
	calls = mock.calls.State
	mock.lockState.RUnlock()
	return calls
}

// Units calls UnitsFunc.
func (mock *SensorStateMock) Units() string {
	if mock.UnitsFunc == nil {
		panic("SensorStateMock.UnitsFunc: method is nil but SensorState.Units was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUnits.Lock()
	mock.calls.Units = append(mock.calls.Units, callInfo)
	mock.lockUnits.Unlock()
	return mock.UnitsFunc()
}

// UnitsCalls gets all the calls that were made to Units.
// Check the length with:
//
//	len(mockedSensorState.UnitsCalls())
func (mock *SensorStateMock) UnitsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUnits.RLock()
	calls = mock.calls.Units
	mock.lockUnits.RUnlock()
	return calls
}
