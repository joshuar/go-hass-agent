// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package agent

import (
	"context"
	"github.com/joshuar/go-hass-agent/internal/hass/sensor"
	"sync"
)

// Ensure, that DeviceMock does implement Device.
// If this is not the case, regenerate this file with moq.
var _ Device = &DeviceMock{}

// DeviceMock is a mock implementation of Device.
//
//	func TestSomethingThatUsesDevice(t *testing.T) {
//
//		// make and configure a mocked Device
//		mockedDevice := &DeviceMock{
//			DeviceIDFunc: func() string {
//				panic("mock out the DeviceID method")
//			},
//			DeviceNameFunc: func() string {
//				panic("mock out the DeviceName method")
//			},
//			SetupFunc: func(ctx context.Context) context.Context {
//				panic("mock out the Setup method")
//			},
//			UpdatesFunc: func() chan sensor.Details {
//				panic("mock out the Updates method")
//			},
//		}
//
//		// use mockedDevice in code that requires Device
//		// and then make assertions.
//
//	}
type DeviceMock struct {
	// DeviceIDFunc mocks the DeviceID method.
	DeviceIDFunc func() string

	// DeviceNameFunc mocks the DeviceName method.
	DeviceNameFunc func() string

	// SetupFunc mocks the Setup method.
	SetupFunc func(ctx context.Context) context.Context

	// UpdatesFunc mocks the Updates method.
	UpdatesFunc func() chan sensor.Details

	// calls tracks calls to the methods.
	calls struct {
		// DeviceID holds details about calls to the DeviceID method.
		DeviceID []struct {
		}
		// DeviceName holds details about calls to the DeviceName method.
		DeviceName []struct {
		}
		// Setup holds details about calls to the Setup method.
		Setup []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Updates holds details about calls to the Updates method.
		Updates []struct {
		}
	}
	lockDeviceID   sync.RWMutex
	lockDeviceName sync.RWMutex
	lockSetup      sync.RWMutex
	lockUpdates    sync.RWMutex
}

// DeviceID calls DeviceIDFunc.
func (mock *DeviceMock) DeviceID() string {
	if mock.DeviceIDFunc == nil {
		panic("DeviceMock.DeviceIDFunc: method is nil but Device.DeviceID was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDeviceID.Lock()
	mock.calls.DeviceID = append(mock.calls.DeviceID, callInfo)
	mock.lockDeviceID.Unlock()
	return mock.DeviceIDFunc()
}

// DeviceIDCalls gets all the calls that were made to DeviceID.
// Check the length with:
//
//	len(mockedDevice.DeviceIDCalls())
func (mock *DeviceMock) DeviceIDCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDeviceID.RLock()
	calls = mock.calls.DeviceID
	mock.lockDeviceID.RUnlock()
	return calls
}

// DeviceName calls DeviceNameFunc.
func (mock *DeviceMock) DeviceName() string {
	if mock.DeviceNameFunc == nil {
		panic("DeviceMock.DeviceNameFunc: method is nil but Device.DeviceName was just called")
	}
	callInfo := struct {
	}{}
	mock.lockDeviceName.Lock()
	mock.calls.DeviceName = append(mock.calls.DeviceName, callInfo)
	mock.lockDeviceName.Unlock()
	return mock.DeviceNameFunc()
}

// DeviceNameCalls gets all the calls that were made to DeviceName.
// Check the length with:
//
//	len(mockedDevice.DeviceNameCalls())
func (mock *DeviceMock) DeviceNameCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockDeviceName.RLock()
	calls = mock.calls.DeviceName
	mock.lockDeviceName.RUnlock()
	return calls
}

// Setup calls SetupFunc.
func (mock *DeviceMock) Setup(ctx context.Context) context.Context {
	if mock.SetupFunc == nil {
		panic("DeviceMock.SetupFunc: method is nil but Device.Setup was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSetup.Lock()
	mock.calls.Setup = append(mock.calls.Setup, callInfo)
	mock.lockSetup.Unlock()
	return mock.SetupFunc(ctx)
}

// SetupCalls gets all the calls that were made to Setup.
// Check the length with:
//
//	len(mockedDevice.SetupCalls())
func (mock *DeviceMock) SetupCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSetup.RLock()
	calls = mock.calls.Setup
	mock.lockSetup.RUnlock()
	return calls
}

// Updates calls UpdatesFunc.
func (mock *DeviceMock) Updates() chan sensor.Details {
	if mock.UpdatesFunc == nil {
		panic("DeviceMock.UpdatesFunc: method is nil but Device.Updates was just called")
	}
	callInfo := struct {
	}{}
	mock.lockUpdates.Lock()
	mock.calls.Updates = append(mock.calls.Updates, callInfo)
	mock.lockUpdates.Unlock()
	return mock.UpdatesFunc()
}

// UpdatesCalls gets all the calls that were made to Updates.
// Check the length with:
//
//	len(mockedDevice.UpdatesCalls())
func (mock *DeviceMock) UpdatesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockUpdates.RLock()
	calls = mock.calls.Updates
	mock.lockUpdates.RUnlock()
	return calls
}
