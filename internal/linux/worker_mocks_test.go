// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package linux

import (
	"context"
	"github.com/joshuar/go-hass-agent/internal/hass/sensor"
	"sync"
	"time"
)

// Ensure, that PollingTypeMock does implement PollingType.
// If this is not the case, regenerate this file with moq.
var _ PollingType = &PollingTypeMock{}

// PollingTypeMock is a mock implementation of PollingType.
//
//	func TestSomethingThatUsesPollingType(t *testing.T) {
//
//		// make and configure a mocked PollingType
//		mockedPollingType := &PollingTypeMock{
//			SensorsFunc: func(ctx context.Context) ([]sensor.Entity, error) {
//				panic("mock out the Sensors method")
//			},
//			UpdateDeltaFunc: func(delta time.Duration)  {
//				panic("mock out the UpdateDelta method")
//			},
//		}
//
//		// use mockedPollingType in code that requires PollingType
//		// and then make assertions.
//
//	}
type PollingTypeMock struct {
	// SensorsFunc mocks the Sensors method.
	SensorsFunc func(ctx context.Context) ([]sensor.Entity, error)

	// UpdateDeltaFunc mocks the UpdateDelta method.
	UpdateDeltaFunc func(delta time.Duration)

	// calls tracks calls to the methods.
	calls struct {
		// Sensors holds details about calls to the Sensors method.
		Sensors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateDelta holds details about calls to the UpdateDelta method.
		UpdateDelta []struct {
			// Delta is the delta argument value.
			Delta time.Duration
		}
	}
	lockSensors     sync.RWMutex
	lockUpdateDelta sync.RWMutex
}

// Sensors calls SensorsFunc.
func (mock *PollingTypeMock) Sensors(ctx context.Context) ([]sensor.Entity, error) {
	if mock.SensorsFunc == nil {
		panic("PollingTypeMock.SensorsFunc: method is nil but PollingType.Sensors was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSensors.Lock()
	mock.calls.Sensors = append(mock.calls.Sensors, callInfo)
	mock.lockSensors.Unlock()
	return mock.SensorsFunc(ctx)
}

// SensorsCalls gets all the calls that were made to Sensors.
// Check the length with:
//
//	len(mockedPollingType.SensorsCalls())
func (mock *PollingTypeMock) SensorsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSensors.RLock()
	calls = mock.calls.Sensors
	mock.lockSensors.RUnlock()
	return calls
}

// UpdateDelta calls UpdateDeltaFunc.
func (mock *PollingTypeMock) UpdateDelta(delta time.Duration) {
	if mock.UpdateDeltaFunc == nil {
		panic("PollingTypeMock.UpdateDeltaFunc: method is nil but PollingType.UpdateDelta was just called")
	}
	callInfo := struct {
		Delta time.Duration
	}{
		Delta: delta,
	}
	mock.lockUpdateDelta.Lock()
	mock.calls.UpdateDelta = append(mock.calls.UpdateDelta, callInfo)
	mock.lockUpdateDelta.Unlock()
	mock.UpdateDeltaFunc(delta)
}

// UpdateDeltaCalls gets all the calls that were made to UpdateDelta.
// Check the length with:
//
//	len(mockedPollingType.UpdateDeltaCalls())
func (mock *PollingTypeMock) UpdateDeltaCalls() []struct {
	Delta time.Duration
} {
	var calls []struct {
		Delta time.Duration
	}
	mock.lockUpdateDelta.RLock()
	calls = mock.calls.UpdateDelta
	mock.lockUpdateDelta.RUnlock()
	return calls
}

// Ensure, that EventTypeMock does implement EventType.
// If this is not the case, regenerate this file with moq.
var _ EventType = &EventTypeMock{}

// EventTypeMock is a mock implementation of EventType.
//
//	func TestSomethingThatUsesEventType(t *testing.T) {
//
//		// make and configure a mocked EventType
//		mockedEventType := &EventTypeMock{
//			EventsFunc: func(ctx context.Context) (<-chan sensor.Entity, error) {
//				panic("mock out the Events method")
//			},
//			SensorsFunc: func(ctx context.Context) ([]sensor.Entity, error) {
//				panic("mock out the Sensors method")
//			},
//		}
//
//		// use mockedEventType in code that requires EventType
//		// and then make assertions.
//
//	}
type EventTypeMock struct {
	// EventsFunc mocks the Events method.
	EventsFunc func(ctx context.Context) (<-chan sensor.Entity, error)

	// SensorsFunc mocks the Sensors method.
	SensorsFunc func(ctx context.Context) ([]sensor.Entity, error)

	// calls tracks calls to the methods.
	calls struct {
		// Events holds details about calls to the Events method.
		Events []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// Sensors holds details about calls to the Sensors method.
		Sensors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockEvents  sync.RWMutex
	lockSensors sync.RWMutex
}

// Events calls EventsFunc.
func (mock *EventTypeMock) Events(ctx context.Context) (<-chan sensor.Entity, error) {
	if mock.EventsFunc == nil {
		panic("EventTypeMock.EventsFunc: method is nil but EventType.Events was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockEvents.Lock()
	mock.calls.Events = append(mock.calls.Events, callInfo)
	mock.lockEvents.Unlock()
	return mock.EventsFunc(ctx)
}

// EventsCalls gets all the calls that were made to Events.
// Check the length with:
//
//	len(mockedEventType.EventsCalls())
func (mock *EventTypeMock) EventsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockEvents.RLock()
	calls = mock.calls.Events
	mock.lockEvents.RUnlock()
	return calls
}

// Sensors calls SensorsFunc.
func (mock *EventTypeMock) Sensors(ctx context.Context) ([]sensor.Entity, error) {
	if mock.SensorsFunc == nil {
		panic("EventTypeMock.SensorsFunc: method is nil but EventType.Sensors was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSensors.Lock()
	mock.calls.Sensors = append(mock.calls.Sensors, callInfo)
	mock.lockSensors.Unlock()
	return mock.SensorsFunc(ctx)
}

// SensorsCalls gets all the calls that were made to Sensors.
// Check the length with:
//
//	len(mockedEventType.SensorsCalls())
func (mock *EventTypeMock) SensorsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSensors.RLock()
	calls = mock.calls.Sensors
	mock.lockSensors.RUnlock()
	return calls
}

// Ensure, that OneShotTypeMock does implement OneShotType.
// If this is not the case, regenerate this file with moq.
var _ OneShotType = &OneShotTypeMock{}

// OneShotTypeMock is a mock implementation of OneShotType.
//
//	func TestSomethingThatUsesOneShotType(t *testing.T) {
//
//		// make and configure a mocked OneShotType
//		mockedOneShotType := &OneShotTypeMock{
//			SensorsFunc: func(ctx context.Context) ([]sensor.Entity, error) {
//				panic("mock out the Sensors method")
//			},
//		}
//
//		// use mockedOneShotType in code that requires OneShotType
//		// and then make assertions.
//
//	}
type OneShotTypeMock struct {
	// SensorsFunc mocks the Sensors method.
	SensorsFunc func(ctx context.Context) ([]sensor.Entity, error)

	// calls tracks calls to the methods.
	calls struct {
		// Sensors holds details about calls to the Sensors method.
		Sensors []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockSensors sync.RWMutex
}

// Sensors calls SensorsFunc.
func (mock *OneShotTypeMock) Sensors(ctx context.Context) ([]sensor.Entity, error) {
	if mock.SensorsFunc == nil {
		panic("OneShotTypeMock.SensorsFunc: method is nil but OneShotType.Sensors was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockSensors.Lock()
	mock.calls.Sensors = append(mock.calls.Sensors, callInfo)
	mock.lockSensors.Unlock()
	return mock.SensorsFunc(ctx)
}

// SensorsCalls gets all the calls that were made to Sensors.
// Check the length with:
//
//	len(mockedOneShotType.SensorsCalls())
func (mock *OneShotTypeMock) SensorsCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockSensors.RLock()
	calls = mock.calls.Sensors
	mock.lockSensors.RUnlock()
	return calls
}
